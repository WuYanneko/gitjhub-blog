---
data: 2024-05-29
tags:
  - Git指令
---
## 4.1设置用户名
### 1.配置git环境：git config --global

参数讲解：

    config：参数是用来配置git环境的

    --global：长命令表示配置整个git环境

初次使用git需要设置你的用户名以及邮箱，这将作为当前机器git的标识，如果你用它来下载远程仓库一些需要登录权限的仓库会要求登录，git默认使用配置邮箱以及用户名登入，但会要求你手动输入密码
### 2.用户名配置

- user代表用户，.name代表配置用户的名称

git config --global user.name "你的用户名"
用户名称只是为了区分不同用户者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。

### 3.邮箱配置

- user代表用户，.email代表配置用户的邮箱

git config --global user.email "你的邮箱"

不配置也行，当遇到要求登录权限的远程仓库会让你在手动输入用户名、邮箱、以及密码
![[Pasted image 20240529203820.png]]
## 4.2初始化本地库
创建本地仓库的条件是需要一个空目录，然后在空目录中初始化你的项目
如我想创建一个名为“test”的空项目
1.创建目录
mkdir test
2.进入目录
cd test
3.使用git init初始化当前仓库
git init
### 1.创建本地空仓库：git init
 - 在文件夹中的项目文件夹的空白处右键点开git可以在此文件夹中直接操作git
 ![[Pasted image 20240529205224.png]]
![[Pasted image 20240529205119.png]]
**=*=没初始化git无权限对此文件夹进行操作==***
- init：初始化当前目录为仓库，初始化后会自动将当前仓库设置为master
![[Pasted image 20240529205532.png]]
生成了一个一个名为".git"的目录，且其在Windows下默认隐藏
- 查看此文件目录用到Linux命令：
![[Pasted image 20240529210600.png]]
![[Pasted image 20240529210710.png]]

用git status 
- 来查看此本地库在哪个分支上（master）
- 提交记录（首次为空目录，没有提交记录及需要提交的文件）
- 需要提交的文件
![[Pasted image 20240530105139.png]]
[[Linux快捷键]]清屏
Linux命令进入Vim
[[Vim快捷键]]进入编辑模式（底部insert）
![[Pasted image 20240530111025.png]]
![[Pasted image 20240530111232.png]]
[[Vim快捷键]]复制
黏贴
（必须退出编辑模式才可以用）
![[Pasted image 20240530111730.png]]
[[Vim命令]]保存
Linux命令查看
![[Pasted image 20240530113318.png]]
Linux命令查看文件内容
![[Pasted image 20240530114157.png]]![[Pasted image 20240530115039.png]]
再次查看本地库的状态用Linux命令
![[Pasted image 20240530115549.png]]
红色表此文件仅存在于工作区（Git機能）中，还未被git追踪(下面有提示)  
![[Pasted image 20240530173037.png]]
### 2.新建文件添加到缓存区：git add
add：将文件添加到缓存区
commit：提交到本地仓库
![[Pasted image 20240530173845.png]]
- 原因是推送的文件中存在LF换行符。
	CRLF和LF是两种换行符，git工作区默认使用CRLF换行符，当我们项目文件里有用存在LF换行符时，push到远程仓库时git会统一将LF换行符转化为CRLF换行符。但是git只修改暂存区文件，而不会修改工作区的文件，因此每次使用git add 或git commit命令时都会弹出上述警告。(==**无影响**==) 
此时再用git status
此时此文件已存在于缓存区[[Git機能]]
![[Pasted image 20240530174405.png]]
 此时git提示：可以把此文件从缓存区删除（注意：只是在缓存区删除了，文件还是存在于工作区）
 ![[Pasted image 20240530175036.png]]
 ![[Pasted image 20240530175212.png]]
 
### 3.把文件提交到本地库：git commit
基本语法：git commit -m"日志信息" 文件名
![[Pasted image 20240530180212.png]]
其中=="832ec34"==为此次的版本号
![[Pasted image 20240530180639.png]]
此时再使用git status,并对比提交到本地库时对比
![[Pasted image 20240530174405.png]]
![[Pasted image 20240530180820.png]]
发现"No commit yet"无，说明已经有版本信息了
“nothing to commit”说明目前没有需要提交的
- 查看历史提交日志：git log/reflog
	log：查看详细日志
	reflog:查看日志
	![[Pasted image 20240531150926.png]]
	log可看到详细的版本号，作者，提交日期
	==***!!!!head此指针指向master这个分枝中的"first demo"这个版本***==

- 修改文件（版本迭代）
![[Pasted image 20240531151454.png]]
此时再用git status查看发现和以前不一样
![[Pasted image 20240530115549.png]]
![[Pasted image 20240531152134.png]]
再次用git add 与git status查看---
![[Pasted image 20240531152440.png]]
用git commit -m"" xxx.xxx
![[Pasted image 20240531152858.png]]
发现有一行增加，一行删减
再次用git log与reflog，查看日志
![[Pasted image 20240531153409.png]]
此时==***!!!!head此指针指向master这个分枝中的"second demo"这个版本
head 指向之处，就是cat 查看此版本的文件的时候
![[Pasted image 20240531155242.png]]

再创建一个新版本的hello.txt
![[Pasted image 20240531160112.png]]
![[Pasted image 20240531160012.png]]
## 4.3历史版本的穿梭
可以先通过git reflog看到各历史版本的基本信息
看到各个版本的版本号后
==利用git reset --hard 版本号 将head 指针指向此版本号对应的历史版本文件==
![[Pasted image 20240601233457.png]]
其中查看日志有将head指针指向指定版本号的信息
==**！！！！！本地工作区的hello.txt文件也随head的改变而改变，工作区的文件是head指向master这个分支中的hello.txt文件，cat hello.txt查看的是工作区的文件**==![[Pasted image 20240601234032.png]]
在.git文件夹中打开head文件，发现head指向master
![[Pasted image 20240601234258.png]]
再打开master文件，可查看当前master分支（指针）下的此次文件版本号


指针示意图：![[Screenshot_20240601_144659.jpg]]
![[Screenshot_20240601_144659.jpg]]
