---
tags:
  - Git指令
data: 2024-06-02
---

### 1.概念
5.1 服务器运行模式

   从右向左看

   用户在生产分支上进行使用，程序员在开发分支上进行开发
   ![[8d0de43cb6d64674807bf63da4408402.png]]

 
5.2  分支概念

   在版本控制过程中，同时推进多个任务，我们就可以创建每个任务单独的分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开，开发自己分支的时候，不会影响主线分支的运行，对初学者来说，分支可以简单的理解为副本，一个分支就是一个单独的副本（分支底层其实也是指针的引用）
	比如下图来说，
	![[b4ffef53cc684769ac3b0459e9a9c1bc.png]]
	![[Screenshot_20240602_232223.jpg]]
	==版本的更替1.0->1.2->2.0(感觉新版本变化比上一个版本打就更新大版本)==
    **在master这个主线上运行，运行的同时要增加功能，那我们就可以把master赋值一份出来，在复制的地方进行开发，在开发完功能后就可以更新版本正常使用**

	====当我们引入新功能有bug，就可以从master分支再引一个分支hot-fix(热修分支)-->紧急bug修改，对代码进行修改，修改后再合并到master======
==
 
 5.3 分支的好处

	 同时并行推进多个功能开发，提高效率

	  各个分支在开发过程中，如果一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即

### 2.分支的操作
![[eb79cef199f74c2abb11b3b275b9963c.png]]
- git branch -v查看当前本地库中有几个分支：
	![[Pasted image 20240602232944.png]]
	发现目前就一个分支-->***==master==***
	
	通过git branch 分支名  来创建新的分支
- 并用git checkout 来切换分支
	
	![[Drawing 2024-06-03 11.55.09.excalidraw.png]]
	在 hot-bug这个分支中修改文件，并add提交到缓存区,commit到版本库：
	![[Pasted image 20240603121115.png]]
	再用git reflog 查看日志信息
	在这可看到各分支有几个版本（提交到本地库有几个版本），什么时候从一个版本切换到另一个历史版本和目前head指针指向哪个分支
	![[Pasted image 20240603121525.png]]
	
	git log查看详细信息：（作者，最新提交时间，提交到本地库的最新版本的详细版本号）
	![[Pasted image 20240603122125.png]]
	查看hot-bug文件发现版本号与master文件中的版本号不一致，即在不同分支下，master指针与hot-bug指针指向的文件可以不一样，体现了分工的理念
	
	==hot-bug版本号：==
	![[Pasted image 20240603121910.png]]
	==master版本号：==
	![[Pasted image 20240603121924.png]]
- 分支的合并 git merge
	- 概念
		Git的设计目标之一就是为了能让开发者之间的分布式协作变得尽可能容易一些。因此从 很大程度上来说，merge 命令应能自动对分支进行合并，完全不需要用户交互。但这是怎么做到的呢?
		例如在下图中，我们会看到某一个文件有两个不同版本，它们分别属于分支a 和分支b。 我们很容易就能看出这其不同之处位于哪几行。但究竟哪一个才是正确的呢?是 “Freitag” 还是 “Montag”? 是 “Git” 还是 “Fit”? 合并算法应该如何作出决定呢?
		![[80d606c4292445baa1cfd234f184d69b.png]]
		在这里插入图片描述
		问题关键就藏在其提交历史之中。这里的窍门就是要找到它们最后一个共同的祖辈提交。 换一种相对简单点的说法，就是要找到其提交路径上岔出分支的那个点。只要我们将该源版本与眼前的这两个分支的版本比对一下，整个画面就会变得更为清晰。
		![[3158a916bc9d41c485af817e0dd290f3 1.png]]
		如你所见，在图下这个例子中，分支 b 中的第一行 “Freitagabend” 被替换成了 “Montagabend” 。 而在分支a 中，第一行则没有被修改。这在进行分支合并时是一个强烈信号， 它告诉我们应该采用包含 “Montagabend” 的版本。通过同样的方式，我们也可以安全地确认，对于最后一行我们应该采用包含“Git”的版本，而不是“Fit”的版本，其最终结果如图所示。
	- 正常合并：（把hot-bug(即要合并到另一个分支的分支),合并到master分支上） 
		![[Pasted image 20240603123952.png]]
		==注意：git merge 分支名，中的分支名是要合并的分支，合并到目前head指向的分支（目前即master）====
		git reflog可以看到相关日志信息：
		![[Pasted image 20240603124442.png]]

		![[Pasted image 20240603130026.png]]
	- 不正常合并（冲突合并）（企业常见）
	  产生原因：合并分支时，两个分支在**同一个文件的同一个位置有两套完全不同的修改**，Git无法替我们决定使用哪一个，必需*==人为决定==*新代码内容 
	  
	  先在hot-bug分支下修改文件（==add,commit==）:
	  ![[Pasted image 20240603194730.png]]
	  再切换分支，在master中修改代码:
	  在修改之前，发现master目前的版本还是第一次与hot-bug正常合并时的版本：
	  ![[Pasted image 20240603195725.png]]
	  对其进行修改并进行add commit:
	  ![[Pasted image 20240603195946.png]]
		 合并：
		 发现自动合并失败：（） 
		 
		 ![[Drawing 2024-06-03 20.02.59.excalidraw.png]]
		MERGING说明正在合并中
		<<<<<
		到>>>>>>>>hot-bug为另一个分支下对文件的修改
		
		
		
		
		![[Drawing 2024-06-03 20.07.56.excalidraw.svg]]
		![[Pasted image 20240603204125.png]]
